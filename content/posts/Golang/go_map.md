---
title: "「Go系列」Map类型深入学习"
date: 2022-08-14T19:13:05+08:00
draft: false
---

Go语言中的Map类型是用来存储键值对的数据结构，例如`map[string]int`就是用来存储键类型为`string`值类型为`int`的键值对。Map底层实际上就是一个哈希表结构，Go中每一个Map类型的变量实际上就是一个指向其对应哈希表的指针。为了搞清楚Go的Map到底长什么样，我们带着以下几个关键问题去翻翻[Map源码](https://github.com/golang/go/blob/master/src/runtime/map.go)：

- Map长什么样？数据结构中有哪些字段？
- Map如何解决哈希冲突？
- 当分配的内存空间不够时候，Map如何进行扩容？

## Map数据结构

Map类型变量都是指向`hmap`结构体的指针，`hmap`可以被理解为是一个Map的header：

```go
type hmap struct {
	count     int 
	flags     uint8
	B         uint8  
	noverflow uint16 
	hash0     uint32 

	buckets    unsafe.Pointer 
	oldbuckets unsafe.Pointer 
	nevacuate  uintptr        

	extra *mapextra 
}
```

其中`count`是当前Map中键值对的总数量，`B`代表的是当前Map中总共有2的`B`次幂个**桶（bucket）**。

### 桶

桶（bucket）是真正用来存放Map中键值对的数据结构，对应Go源码当中的`bmap`结构：

```go
type bmap struct {
	tophash [bucketCnt]uint8
}
```

源码中只给出了`bmap`中的其中一个组成——`tophash`，是一个大小为`bucketCnt`的数组，用于存放**当前桶中键值对中键的哈希值的高八位**，且`bucketCnt`是一个固定的常数8。一个桶的具体数据结构如下图：

![bmap](/images/Golang/go-map/bmap.png)

桶中紧挨着`tophash`的就是8个键和8个值，值得注意的是Go中桶将键和值分开集中存放，这种虽然没有将键值对放一起那样直观，但是这样可以解决内存对齐的问题。

Go语言中的Map在根据一个键去定位对应的值的时候，通过对键进行哈希得到哈希值`hash`，然后`hash & (2^B - 1)`，得到的结果便是存放该键对应值的桶，这也就解释了为什么`hmap`中存放的是`B`，因为桶的个数必然得是2的`B`次幂，这样才能保证根据键的哈希`hash`一定能找到一个对应的桶。

## 解决哈希冲突

当Map中数据比较多的时候，难免会出现两个不同的键经过哈希后得到了相同的哈希值，进而会导致这两个键定位到同一个桶，这样就产生了哈希冲突。

一般解决哈希冲突的办法是**开放寻址法**和**拉链法**：

- 开放寻址法：当产生哈希冲突时，继续顺序地往后面的桶进行遍历，直到找到存放该键值对的桶；
- 拉链法：当产生哈希冲突时，将该键值对也存入桶中，排在桶中已有键值对后面。

根据之前看的`bmap`结构，显而易见Go采用的是拉链法去解决哈希冲突。

当一个桶中因为哈希冲突过多导致初始的8个键值对容量放不下了，那么还会在这个桶后面链接一个**溢出桶（overflow bucket）**，结构和普通的桶是一样的。实际上Go语言中认为当哈希表要分配的桶的数目大于2^4，就会预分配2^(B-4)个溢出桶备用。这些常规桶和溢出桶在内存中是连续的，只是前2^B个用作常规桶，后面的用作溢出桶。

`hmap`中的`extra`字段指向的`mapextra`结构体就是当当前Map使用溢出桶的时候要记录的溢出桶相关的信息：

```go
type mapextra struct {
    overflow    *[]*bmap // 当前Map用到的溢出桶
	oldoverflow *[]*bmap // 扩容时存放旧桶中用到的溢出桶
	nextOverflow *bmap // 下一个尚未使用的溢出桶
}
```

如果当前桶存满了以后，检查`hmap.extra.nextoverflow`还有可用的溢出桶，就在这个桶后面链上这个溢出桶，然后继续往这个溢出桶里存。而`hmap.extra.nextoverflow`继续指向下一个空闲的溢出桶：

![overflow](/images/Golang/go-map/overflow.png)

## Map扩容

Map的扩容分为**翻倍扩容**和**等量扩容**。

### 翻倍扩容

当当前Map的键值对数量和桶数量的比值超过负载因子（默认6.5）的时候，就会触发Map的翻倍扩容，会在内存中分配相较于旧桶数量两倍的新桶。如果此时简单粗暴地将旧桶中数据完整拷贝到新桶中，那么势必会带来性能上的明显抖动，因此Go采用了更柔和的一种方式：**渐进式扩容**。

将`hmap.oldbuckets`指向旧桶、`hmap.buckets`指向新桶、`hmap.nevacuate`赋值0表示接下来要迁移的是0号旧桶。接下来就采用渐进式扩容的方式，在每次读写当前Map时通过判断`hmap.oldbuckets != nil`来确定当前Map处于迁移状态中，然后执行一次迁移操作：将`hmap.nevacuate`表示的旧桶迁移到新桶。

![grow](/images/Golang/go-map/grow.png)

当一个旧桶中的键值对被迁移到新桶的过程中，这个旧桶中的键值对会被分流到两个新桶中去，为什么呢？

假设旧桶的数量是`m=4`，那翻倍扩容的新桶数量是`2m=8`，如果一个键经过哈希后选择0号旧桶，即`hash & (m - 1) == 0`，那么它的哈希值低2位一定是0：`xxxxxx00 & 00000011 == 00000000`。进而对于新桶，该键经哈希后选择的新桶，也就是`hash & (2m - 1) == xxxxxb00 & 00000111`的结果就取决于哈希值第三位`b`的取值了，如果`b=1`那么该键就会选择4号桶，否则选择0号桶。又因为桶的数量永远是2的整数次幂，所以每次翻倍扩容旧桶的键值对都会按照这样的规律被这样分流到新桶中去。

### 等量扩容

如果没有超过负载因子，使用溢出桶太多也会触发扩容，但是触发的是等量扩容。等量扩容就是新桶的数量和旧桶数量一致。

于是就有这样的问题了：

- 用了多少溢出桶算多？
- 既然新桶数量和旧桶数量一致，那何苦迁移来迁移去呢？

首先看第一个问题，Go语言中对于触发等量扩容的溢出桶数量标准是：

- 如果常规桶数目不大于2^15，那么使用的溢出桶数目超过常规桶就算是多了；
- 如果常规桶数目大于2^15，那么使用溢出桶数目一旦超过2^15就算多了。

再看第二个问题，触发等量扩容时候的情况实际上是Map中键值对数量与桶数量比值比较低，没有超过负载因子，可又使用的溢出桶特别多。这种情况只有可能是键值对被删除了很多，导致桶中的键值对数据排列的很稀疏。这时候分配一样数量的新桶，键值对虽然不会因此被分配到别的编号的新桶，但是会让桶中的键值对排列地更紧凑，进而使得Map所占空间变小。

## 总结

以上就是对Go语言中Map底层实现的讲解，这时再想想当写Go代码时，如果我们对Map元素进行取地址操作时编译器会报错，就能解释得通了，因为Map中的键值对会因为迁移而自动改变地址。
